function relu(t){return Math.max(0,t)}function drelu(t){return t>0?1:0}function randn(){return 2*Math.random()-1}function clippedRelu(t,e=1){return Math.max(0,Math.min(e,t))}function dClippedRelu(t,e=1){return t>0&&t<e?1:0}function leakyRelu(t){return t>0?t:.01*t}function dLeakyRelu(t){return t>0?1:.01}function sigmoid(t){return 1/(1+Math.exp(-t))}function dsigmoid(t){const e=sigmoid(t);return e*(1-e)}function tanh(t){return Math.tanh(t)}function dtanh(t){return 1-Math.pow(Math.tanh(t),2)}function softmax(t){const e=Math.max(...t),i=t.map(t=>Math.exp(t-e)),o=i.reduce((t,e)=>t+e,0);return i.map(t=>t/o)}function clip(t,e,i){return Math.max(e,Math.min(i,t))}function clipArray(t,e,i){return t.map(t=>clip(t,e,i))}const ActivationLookup={relu:[relu,drelu],leakyRelu:[leakyRelu,dLeakyRelu],clippedRelu:[(t,e=1)=>clippedRelu(t,e),(t,e=1)=>dClippedRelu(t,e)],sigmoid:[sigmoid,dsigmoid],tanh:[tanh,dtanh]};class FlexibleNN{constructor(t){this.layerSizes=t.layerSizes,this.learningRate=t.learningRate??.01,this.clipValue=t.clipValue??Number.MAX_SAFE_INTEGER/2,this.activationCap=t.activationCap??1,this.activationName=t.activationName??"relu",this.outputActivationName=t.outputActivationName??null,this.outputActivationCap=t.outputActivationCap??1,"clippedRelu"===t.activationName?(this.activation=t=>ActivationLookup.clippedRelu[0](t,this.activationCap),this.dActivation=t=>ActivationLookup.clippedRelu[1](t,this.activationCap)):(this.activation=ActivationLookup[t.activationName][0]??ActivationLookup.relu[0],this.dActivation=ActivationLookup[t.activationName][1]??ActivationLookup.relu[1]),t.outputActivation?(this.outputActivation=t.outputActivation,this.dOutputActivation=t.dOutputActivation??(t=>1)):"clippedRelu"===t.outputActivationName?(this.outputActivation=e=>ActivationLookup.clippedRelu[0](e,t.outputActivationCap??1),this.dOutputActivation=e=>ActivationLookup.clippedRelu[1](e,t.outputActivationCap??1)):t.outputActivationName&&ActivationLookup[t.outputActivationName]?(this.outputActivation=ActivationLookup[t.outputActivationName][0],this.dOutputActivation=ActivationLookup[t.outputActivationName][1]):(this.outputActivation=t=>t,this.dOutputActivation=t=>1),this.weights=[],this.biases=[];for(let t=0;t<this.layerSizes.length-1;t++)this.weights.push(Array.from({length:this.layerSizes[t+1]},()=>Array.from({length:this.layerSizes[t]},randn))),this.biases.push(Array.from({length:this.layerSizes[t+1]},()=>0))}forward(t){this.zs=[],this.as=[t.slice()];for(let t=0;t<this.weights.length;++t){const e=this.as[t];let i=this.weights[t].map((i,o)=>i.reduce((t,i,o)=>t+i*e[o],this.biases[t][o]));i=clipArray(i,-this.clipValue,this.clipValue),this.zs.push(i);const o=t===this.weights.length-1?i.map(this.outputActivation):i.map(this.activation);this.as.push(o)}return this.as[this.as.length-1]}backward(t){const e=this.weights.length;let i=this.weights.map(t=>t.map(t=>t.map(t=>0))),o=this.biases.map(t=>t.map(t=>0)),a=this.as[e].map((e,i)=>2*(e-t[i]));for(let t=e-1;t>=0;--t){for(let e=0;e<this.weights[t].length;++e){for(let o=0;o<this.weights[t][e].length;++o)i[t][e][o]=a[e]*this.as[t][o];o[t][e]=a[e]}if(t>0){const e=[];for(let i=0;i<this.layerSizes[t];++i){let o=0;for(let e=0;e<this.layerSizes[t+1];++e)o+=this.weights[t][e][i]*a[e];o*=this.dActivation(this.zs[t-1][i]),e.push(o)}a=e}}for(let t=0;t<this.weights.length;++t)for(let e=0;e<this.weights[t].length;++e){for(let o=0;o<this.weights[t][e].length;++o){let a=this.learningRate*i[t][e][o];a=clip(a,-this.clipValue,this.clipValue),this.weights[t][e][o]-=a,this.weights[t][e][o]=clip(this.weights[t][e][o],-this.clipValue,this.clipValue)}let a=this.learningRate*o[t][e];a=clip(a,-this.clipValue,this.clipValue),this.biases[t][e]-=a,this.biases[t][e]=clip(this.biases[t][e],-this.clipValue,this.clipValue)}}train(t,e,i=100){for(let o=0;o<i;++o){let i=0;for(let o=0;o<t.length;++o){const a=this.forward(t[o]);i+=a.reduce((t,i,a)=>t+(i-e[o][a])**2,0)/a.length,this.backward(e[o])}console.log(`Epoch ${o+1} â€“ Loss: ${(i/t.length).toFixed(12)}`)}}predict(t){return this.forward(t)}static async loadBinModelToIndexedDB(t,e,{quantized:i=!1,bits:o=8}={}){const a=await fetch(t);if(!a.ok)throw new Error(`Failed to fetch model: ${a.status}`);if(i&&32!==o){if(8!==o)throw new Error("Only 8-bit quantization supported in this example");const t=await a.arrayBuffer();let i=0,n=new DataView(t).getUint32(i,!0);i+=4;let s=(new TextDecoder).decode(new Uint8Array(t,i,n));i+=n;const r=JSON.parse(s);let l=[],c=[];for(let e=0;e<r.layerSizes.length-1;++e){let o=r.layerSizes[e],a=r.layerSizes[e+1],n=o*a,s=a,u=new Int8Array(t,i,n);i+=n;let[h,p]=r.weightsMinMax[e],d=[];for(let t=0;t<a;++t){let e=[];for(let i=0;i<o;++i){let a=h+(u[t*o+i]+128)/255*(p-h);e.push(a)}d.push(e)}l.push(d);let m=new Int8Array(t,i,s);i+=s;let[w,g]=r.biasesMinMax[e],f=[];for(let t=0;t<s;++t){let e=w+(m[t]+128)/255*(g-w);f.push(e)}c.push(f)}const u={...r,weights:l,biases:c},h=await FlexibleNN._openDB();return new Promise((t,i)=>{const o=h.transaction("models","readwrite");o.objectStore("models").put(u,e),o.oncomplete=()=>{h.close(),t(!0)},o.onerror=t=>{h.close(),i(t)}})}{const t=await a.text();let i;try{i=JSON.parse(t)}catch(t){throw new Error("Invalid .bin model file: "+t.message)}const o=await FlexibleNN._openDB();return new Promise((t,a)=>{const n=o.transaction("models","readwrite");n.objectStore("models").put(i,e),n.oncomplete=()=>{o.close(),t(!0)},n.onerror=t=>{o.close(),a(t)}})}}static async importModelFromFile(t,e){const i=await FlexibleNN._openDB();return new Promise((o,a)=>{const n=new FileReader;n.onload=function(t){try{const n=JSON.parse(t.target.result),s=i.transaction("models","readwrite");s.objectStore("models").put(n,e),s.oncomplete=()=>{i.close(),o(!0)},s.onerror=t=>{i.close(),a(t)}}catch(t){i.close(),a(t)}},n.onerror=function(t){i.close(),a(t)},n.readAsText(t)})}async saveModel(t){const e=await FlexibleNN._openDB(),i={layerSizes:this.layerSizes,learningRate:this.learningRate,weights:this.weights,biases:this.biases,activationName:this.activationName,activationCap:this.activationCap,outputActivationName:this.outputActivationName,outputActivationCap:this.outputActivationCap};return new Promise((o,a)=>{const n=e.transaction("models","readwrite");n.objectStore("models").put(i,t),n.oncomplete=()=>{e.close(),o(!0)},n.onerror=t=>{e.close(),a(t)}})}static async exportModelToBinFile({key:t,quantized:e=!1,bits:i=8}){const o=await FlexibleNN._openDB();return new Promise((a,n)=>{const s=o.transaction("models","readonly").objectStore("models").get(t);s.onsuccess=()=>{if(o.close(),!s.result)return n(new Error("Model not found for key: "+t));const r=s.result;if(!e||32===i){const e=JSON.stringify(r),i=new Blob([e],{type:"application/octet-stream"}),o=URL.createObjectURL(i),n=document.createElement("a");return n.href=o,n.download=`${t}.bin`,document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(o),void a(!0)}if(8!==i)return n(new Error("Only 8-bit quantization is supported"));let l={weights:[],weightsMinMax:[],biases:[],biasesMinMax:[]};for(let t=0;t<r.weights.length;++t){let e=r.weights[t].flat(),i=Math.min(...e),o=Math.max(...e);l.weightsMinMax.push([i,o]);let a=e.map(t=>Math.round((t-i)/(o-i||1)*255)-128);l.weights.push(Int8Array.from(a));let n=r.biases[t],s=Math.min(...n),c=Math.max(...n);l.biasesMinMax.push([s,c]);let u=n.map(t=>Math.round((t-s)/(c-s||1)*255)-128);l.biases.push(Int8Array.from(u))}const c={layerSizes:r.layerSizes,activationName:r.activationName,activationCap:r.activationCap,outputActivationName:r.outputActivationName,outputActivationCap:r.outputActivationCap,weightsMinMax:l.weightsMinMax,biasesMinMax:l.biasesMinMax};let u=JSON.stringify(c),h=[new Uint32Array([u.length]).buffer,(new TextEncoder).encode(u)];for(let t=0;t<l.weights.length;++t)h.push(l.weights[t].buffer),h.push(l.biases[t].buffer);let p=new Blob(h,{type:"application/octet-stream"});const d=URL.createObjectURL(p),m=document.createElement("a");m.href=d,m.download=`${t}_8bit.bin`,document.body.appendChild(m),m.click(),document.body.removeChild(m),URL.revokeObjectURL(d),a(!0)},s.onerror=t=>{o.close(),n(t)}})}static async import8bitBinModelToIndexedDB(t,e){const i=await t.arrayBuffer();let o=0,a=new DataView(i).getUint32(o,!0);o+=4;let n=(new TextDecoder).decode(new Uint8Array(i,o,a));o+=a;const s=JSON.parse(n);let r=[],l=[];for(let t=0;t<s.layerSizes.length-1;++t){let e=s.layerSizes[t],a=s.layerSizes[t+1],n=e*a,c=a,u=new Int8Array(i,o,n);o+=n;let[h,p]=s.weightsMinMax[t],d=[];for(let t=0;t<a;++t){let i=[];for(let o=0;o<e;++o){let a=h+(u[t*e+o]+128)/255*(p-h);i.push(a)}d.push(i)}r.push(d);let m=new Int8Array(i,o,c);o+=c;let[w,g]=s.biasesMinMax[t],f=[];for(let t=0;t<c;++t){let e=w+(m[t]+128)/255*(g-w);f.push(e)}l.push(f)}const c={...s,weights:r,biases:l},u=await FlexibleNN._openDB();return new Promise((t,i)=>{const o=u.transaction("models","readwrite");o.objectStore("models").put(c,e),o.oncomplete=()=>{u.close(),t(!0)},o.onerror=t=>{u.close(),i(t)}})}static async loadModel(t){const e=await FlexibleNN._openDB();return new Promise((i,o)=>{const a=e.transaction("models","readonly").objectStore("models").get(t);a.onsuccess=()=>{if(e.close(),!a.result)return o(new Error("Model not found for key "+t));const n=(new FlexibleNNBuilder).withLayerSizes(a.result.layerSizes).withLearningRate(a.result.learningRate).withActivation(a.result.activationName,a.result.activationCap).withOutputActivation(a.result.outputActivationName,a.result.outputActivationCap).build();n.weights=a.result.weights,n.biases=a.result.biases,i(n)},a.onerror=t=>{e.close(),o(t)}})}static _openDB(){return new Promise((t,e)=>{const i=indexedDB.open("SimpleNN_DB",1);i.onupgradeneeded=function(){i.result.objectStoreNames.contains("models")||i.result.createObjectStore("models")},i.onsuccess=()=>t(i.result),i.onerror=t=>e(t)})}}class FlexibleNNBuilder{constructor(){this.config={}}withLayerSizes(t){return this.config.layerSizes=t,this}withLearningRate(t){return this.config.learningRate=t,this}withClipValue(t){return this.config.clipValue=t??Number.MAX_SAFE_INTEGER/2,this}withActivation(t,e=1){return this.config.activationName=t,this.config.activationCap=e,this.config.activation=t,this}withCustomActivation(t,e){return this.config.activation=t,this.config.dActivation=e,this}withOutputActivation(t,e=1){return this.config.outputActivationName=t,this.config.outputActivationCap=e,this}withCustomOutputActivation(t,e){return this.config.outputActivation=t,this.config.dOutputActivation=e,this}build(){if(!this.config.layerSizes)throw new Error("Must set layerSizes");return new FlexibleNN(this.config)}}window.FlexibleNN=FlexibleNN,window.FlexibleNNBuilder=FlexibleNNBuilder;